// Hide deprecation warnings
process.removeAllListeners('warning');
// Or specifically for punycode:
process.env.NODE_NO_WARNINGS = '1';

// Load environment variables
require('dotenv').config();

const Web3 = require('web3');
const { ethers } = require('ethers');
const yaml = require('js-yaml');
const fs = require('fs');
const path = require('path');

// Add global error handlers with better detail
process.on('unhandledRejection', (error, promise) => {
    console.log('⚠️ Unhandled Promise Rejection:', {
        error: error.message,
        stack: error.stack
    });
});

process.on('uncaughtException', (error) => {
    console.log('⚠️ Uncaught Exception:', {
        error: error.message,
        stack: error.stack
    });
});

class ArbitrageScanner {
    constructor() {
        // Add ANSI color codes first
        this.colors = {
            reset: '\x1b[0m',
            red: '\x1b[31m',
            green: '\x1b[32m',
            yellow: '\x1b[33m',
            blue: '\x1b[34m',
            magenta: '\x1b[35m',
            cyan: '\x1b[36m',
            white: '\x1b[37m',
            // Bright variants
            brightRed: '\x1b[91m',
            brightGreen: '\x1b[92m',
            brightYellow: '\x1b[93m',
            brightBlue: '\x1b[94m',
            brightMagenta: '\x1b[95m',
            brightCyan: '\x1b[96m',
            brightWhite: '\x1b[97m'
        };

        // Initialize logging
        this.log = (message, type = 'info', functionName = '') => {
            const timestamp = new Date().toISOString();
            let color = this.colors.white;

            switch (type.toLowerCase()) {
                case 'error':
                    color = this.colors.brightRed;
                    break;
                case 'warning':
                    color = this.colors.brightYellow;
                    break;
                case 'success':
                    color = this.colors.brightGreen;
                    break;
                case 'info':
                    color = this.colors.brightBlue;
                    break;
                case 'debug':
                    color = this.colors.brightCyan;
                    break;
            }

            const logMessage = `${color}[${timestamp}] [${type.toUpperCase()}] ${functionName ? `[${functionName}] ` : ''}${message}${this.colors.reset}`;
            console.log(logMessage);

            if (this.logFile) {
                const fs = require('fs');
                const cleanMessage = `[${timestamp}] [${type.toUpperCase()}] ${functionName ? `[${functionName}] ` : ''}${message}`;
                fs.appendFileSync(this.logFile, cleanMessage + '\n');
            }
        };

        try {
            const configPath = path.join(__dirname, 'config.yaml');
            if (!fs.existsSync(configPath)) {
                this.log('config.yaml not found', 'error', 'constructor');
                process.exit(1);
            }

            this.config = yaml.load(fs.readFileSync(configPath, 'utf8'));

            // Validate config sections
            if (!this.config.addresses || !this.config.dexes || !this.config.tradingPairs) {
                this.log('Missing required configuration sections', 'error', 'constructor');
                process.exit(1);
            }

            // Load addresses
            this.ADDRESSES = this.config.addresses;
            this.log('Contract addresses loaded from config.yaml', 'success', 'constructor');

            // Load DEX configurations
            this.DEX_ROUTERS = this.config.dexes.routers;
            this.DEX_FACTORIES = this.config.dexes.factories;
            this.log('DEX configurations loaded from config.yaml', 'success', 'constructor');

            // Load trading parameters
            this.MIN_PROFIT_THRESHOLD = this.config.tradingParameters.minProfitThreshold;
            this.SCAN_INTERVAL = this.config.tradingParameters.scanIntervalMs;
            this.GAS_LIMIT = this.config.tradingParameters.gasLimit;
            this.log('Trading parameters loaded from config.yaml', 'success', 'constructor');

            // Load environment variables for sensitive data
            require('dotenv').config();

            if (!process.env.PRIVATE_KEY) {
                this.log('No private key found in .env', 'error', 'constructor');
                process.exit(1);
            }

            // Initialize provider with environment variables
            this.provider = new ethers.providers.JsonRpcProvider(
                process.env.RPC_URL || 'https://polygon-rpc.com'
            );
            this.signer = new ethers.Wallet(process.env.PRIVATE_KEY, this.provider);

            this.log('Initialization completed successfully', 'success', 'constructor');

        } catch (error) {
            this.log(`Failed to initialize: ${error.message}`, 'error', 'constructor');
            process.exit(1);
        }

        // Add config loading
        try {
            const fs = require('fs');
            const path = require('path');

            // Load config.yaml
            const configPath = path.join(__dirname, 'config.yaml');
            if (fs.existsSync(configPath)) {
                this.config = yaml.load(fs.readFileSync(configPath, 'utf8'));
                this.log('Configuration loaded successfully', 'success', 'constructor');
            } else {
                this.log('config.yaml not found, using default configuration', 'warning', 'constructor');
                // Use existing configuration as fallback
                this.config = {
                    tradingPairs: [
                        {
                            name: 'WETH/USDC',
                            token0Address: this.ADDRESSES.WETH,
                            token1Address: this.ADDRESSES.USDC,
                            token0Symbol: 'WETH',
                            token1Symbol: 'USDC',
                            token0Decimals: 18,
                            token1Decimals: 6
                        }
                    ]
                };
            }
        } catch (error) {
            this.log(`Error loading config.yaml: ${error.message}, using default configuration`, 'warning', 'constructor');
            // Use existing configuration as fallback
            this.config = {
                tradingPairs: [
                    {
                        name: 'WETH/USDC',
                        token0Address: this.ADDRESSES.WETH,
                        token1Address: this.ADDRESSES.USDC,
                        token0Symbol: 'WETH',
                        token1Symbol: 'USDC',
                        token0Decimals: 18,
                        token1Decimals: 6
                    }
                ]
            };
        }
    }

    async initialize() {
        try {
            this.log('Initializing contracts...', 'info', 'initialize');
            await this.initializeContracts();
            this.log('Initialization complete', 'success', 'initialize');
        } catch (error) {
            this.log(`Initialization failed: ${error.message}`, 'error', 'initialize');
            process.exit(1);
        }
    }

    async initializeContracts() {
        if (!this.provider || !this.signer) {
            this.log('Provider or signer not initialized', 'error', 'initializeContracts');
            process.exit(1);
        }

        // Update the Pool ABI to include only the necessary functions
        const poolABI = [
            "function flashLoanSimple(address receiverAddress, address asset, uint256 amount, bytes calldata params, uint16 referralCode) external returns (bool)",
            "function getReserveData(address asset) external view returns (tuple(uint256 configuration, uint128 liquidityIndex, uint128 currentLiquidityRate, uint128 variableBorrowIndex, uint128 currentVariableBorrowRate, uint128 currentStableBorrowRate, uint40 lastUpdateTimestamp, address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress, address interestRateStrategyAddress, uint8 id))"
        ];

        try {
            // Keep existing initialization
            this.flashLoanPool = new ethers.Contract(
                this.ADDRESSES.AAVE_V3_POOL,
                poolABI,
                this.signer
            );

            // Verify pool contract exists
            const code = await this.provider.getCode(this.ADDRESSES.AAVE_V3_POOL);
            if (code === '0x' || code === '0x0') {
                this.log('AAVE V3 Pool contract not found at specified address', 'error', 'initializeContracts');
                process.exit(1);
            }

            // Get WETH contract with minimal ABI
            const wethContract = new ethers.Contract(
                this.ADDRESSES.WETH,
                ['function balanceOf(address) view returns (uint256)'],
                this.provider
            );

            try {
                const poolBalance = await wethContract.balanceOf(this.ADDRESSES.AAVE_V3_POOL);
                this.log(`AAVE V3 Pool WETH balance: ${this.formatAmount(poolBalance)} WETH`, 'info', 'initializeContracts');

                if (poolBalance.isZero()) {
                    this.log('Warning: AAVE V3 Pool has no WETH liquidity', 'warning', 'initializeContracts');
                }
            } catch (balanceError) {
                this.log(`Error checking WETH balance: ${balanceError.message}`, 'warning', 'initializeContracts');
            }

            this.log(`AAVE V3 Pool contract verified at ${this.formatAddress(this.ADDRESSES.AAVE_V3_POOL)}`, 'success', 'initializeContracts');

        } catch (error) {
            this.log(`Failed to verify AAVE V3 Pool: ${error.message}`, 'error', 'initializeContracts');
            process.exit(1);
        }
    }

    // Helper method to format addresses
    formatAddress(address) {
        return `${this.colors.brightMagenta}${address}${this.colors.reset}`;
    }

    // Helper method to format amounts
    formatAmount(amount, decimals = 18, symbol = '') {
        const formatted = ethers.utils.formatUnits(amount, decimals);
        return `${this.colors.brightCyan}${formatted}${symbol ? ' ' + symbol : ''}${this.colors.reset}`;
    }

    async startScanning() {
        try {
            this.log('Starting arbitrage scanner...', 'info', 'startScanning');

            const TRADING_PAIRS = this.config.tradingPairs;

            if (!TRADING_PAIRS || TRADING_PAIRS.length === 0) {
                this.log('No trading pairs configured', 'error', 'startScanning');
                process.exit(1);
            }

            while (true) {
                for (const pair of TRADING_PAIRS) {
                    try {
                        this.log(`\n${this.colors.brightCyan}Checking ${pair.name}...${this.colors.reset}`, 'info', 'startScanning');
                        this.log(`Token0: ${pair.token0Symbol} (${pair.token0Address})`, 'debug', 'startScanning');
                        this.log(`Token1: ${pair.token1Symbol} (${pair.token1Address})`, 'debug', 'startScanning');

                        // Check each DEX
                        for (const dex in this.DEX_ROUTERS) {
                            try {
                                this.log(`\nChecking ${dex}...`, 'info', 'startScanning');

                                // Check liquidity
                                const liquidityInfo = await this.checkLiquidity(
                                    dex,
                                    pair.token0Address,
                                    pair.token1Address
                                );

                                if (!liquidityInfo) {
                                    this.log(`No liquidity found on ${dex} for ${pair.name}`, 'warning', 'startScanning');
                                    this.log(`Router: ${this.DEX_ROUTERS[dex]}`, 'debug', 'startScanning');
                                    this.log(`Factory: ${this.DEX_FACTORIES[dex]}`, 'debug', 'startScanning');
                                    continue;
                                }

                                // Show liquidity info
                                this.log('Liquidity Info:', 'info', 'startScanning');
                                if (liquidityInfo.reserves) {
                                    this.log(`- ${pair.token0Symbol}: ${ethers.utils.formatUnits(liquidityInfo.reserves[pair.token0Symbol], pair.token0Decimals)}`, 'info', 'startScanning');
                                    this.log(`- ${pair.token1Symbol}: ${ethers.utils.formatUnits(liquidityInfo.reserves[pair.token1Symbol], pair.token1Decimals)}`, 'info', 'startScanning');
                                }
                                if (liquidityInfo.price) {
                                    this.log(`- Price: ${ethers.utils.formatUnits(liquidityInfo.price, 18)}`, 'info', 'startScanning');
                                }

                                // Check for arbitrage opportunity
                                const opportunity = {
                                    dex,
                                    liquidityInfo,
                                    price: liquidityInfo.price,
                                    profitPercent: 0
                                };

                                // Calculate profitability
                                const profitability = await this.calculateProfitability(opportunity, pair);

                                // Show profitability results
                                this.log(`\n${dex} Profitability:`, 'info', 'startScanning');
                                this.log(`- Raw Profit: ${profitability.profitPercent.toFixed(4)}%`,
                                    profitability.isViable ? 'success' : 'warning',
                                    'startScanning'
                                );
                                this.log(`- Gas Cost: ${ethers.utils.formatEther(profitability.gasCost)} MATIC`, 'info', 'startScanning');
                                this.log(`- Net Profit: ${(profitability.profitPercent - Number(ethers.utils.formatEther(profitability.gasCost))).toFixed(4)}%`,
                                    profitability.isViable ? 'success' : 'warning',
                                    'startScanning'
                                );

                                if (profitability.isViable) {
                                    this.log(`Found viable opportunity on ${dex}!`, 'success', 'startScanning');
                                    // Execute the arbitrage
                                    await this.executeArbitrage(opportunity, pair);
                                }

                            } catch (dexError) {
                                this.log(`Error checking ${dex}: ${dexError.message}`, 'error', 'startScanning');
                            }
                        }

                    } catch (pairError) {
                        this.log(`Error checking pair ${pair.name}: ${pairError.message}`, 'error', 'startScanning');
                    }
                }

                this.log(`\n${this.colors.brightYellow}───────────────────── Waiting ${this.SCAN_INTERVAL}ms ─────────────────────${this.colors.reset}`);
                await new Promise(resolve => setTimeout(resolve, this.SCAN_INTERVAL));
            }

        } catch (error) {
            this.log(`Fatal error in scanner: ${error.message}`, 'error', 'startScanning');
            process.exit(1);
        }
    }

    async checkLiquidity(dexName, token0Address, token1Address) {
        try {
            const currentPair = this.config.tradingPairs.find(
                pair => pair.token0Address.toLowerCase() === token0Address.toLowerCase() &&
                       pair.token1Address.toLowerCase() === token1Address.toLowerCase()
            );

            if (!currentPair) {
                this.log(`Trading pair not found in configuration for ${token0Address}/${token1Address}`, 'warning', 'checkLiquidity');
                return null;
            }

            // Choose the appropriate DEX handler
            switch(dexName) {
                case 'QuickSwap':
                case 'SushiSwap':
                    return await this.checkUniswapV2Liquidity(dexName, currentPair);

                case 'UniswapV3':
                    return await this.checkUniswapV3Liquidity(dexName, currentPair);

                case 'OneInch':
                    return await this.checkOneInchLiquidity(dexName, currentPair);

                case 'KyberSwap':
                    return await this.checkKyberSwapLiquidity(dexName, currentPair);

                default:
                    this.log(`Unsupported DEX: ${dexName}`, 'warning', 'checkLiquidity');
                    return null;
            }

        } catch (error) {
            this.log(`Error checking liquidity on ${dexName}: ${error.message}`, 'error', 'checkLiquidity');
            return null;
        }
    }

    // Handler for UniswapV2-style DEXes (QuickSwap, SushiSwap)
    async checkUniswapV2Liquidity(dexName, currentPair) {
        try {
            // Validate input parameters
            if (!currentPair || !currentPair.token0Address || !currentPair.token1Address) {
                this.log(`Invalid pair configuration: ${JSON.stringify(currentPair)}`, 'error', 'checkUniswapV2Liquidity');
                return null;
            }

            // Validate addresses are proper hex strings
            if (!ethers.utils.isAddress(currentPair.token0Address) || !ethers.utils.isAddress(currentPair.token1Address)) {
                this.log(`Invalid token addresses: ${currentPair.token0Address} / ${currentPair.token1Address}`, 'error', 'checkUniswapV2Liquidity');
                return null;
            }

            const factoryAddress = this.DEX_FACTORIES[dexName];

            // Debug log the addresses we're using
            this.log(`Checking ${dexName} factory: ${factoryAddress}`, 'debug', 'checkUniswapV2Liquidity');
            this.log(`Token pair: ${currentPair.token0Symbol}/${currentPair.token1Symbol}`, 'debug', 'checkUniswapV2Liquidity');
            this.log(`Token0: ${currentPair.token0Symbol} (${currentPair.token0Address})`, 'debug', 'checkUniswapV2Liquidity');
            this.log(`Token1: ${currentPair.token1Symbol} (${currentPair.token1Address})`, 'debug', 'checkUniswapV2Liquidity');

            // Ensure we're using checksummed addresses
            const token0Address = ethers.utils.getAddress(currentPair.token0Address);
            const token1Address = ethers.utils.getAddress(currentPair.token1Address);

            const factory = new ethers.Contract(
                factoryAddress,
                [
                    'function getPair(address tokenA, address tokenB) view returns (address)',
                    'function allPairs(uint) view returns (address)',
                    'function allPairsLength() view returns (uint)'
                ],
                this.provider
            );

            const pairAddress = await factory.getPair(
                token0Address,
                token1Address
            );

            this.log(`Pair address: ${pairAddress}`, 'debug', 'checkUniswapV2Liquidity');

            if (!pairAddress || pairAddress === ethers.constants.AddressZero) {
                this.log(`No pair contract found for ${currentPair.name} on ${dexName}`, 'debug', 'checkUniswapV2Liquidity');
                return null;
            }

            const pairABI = [
                'function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)',
                'function token0() external view returns (address)',
                'function token1() external view returns (address)'
            ];

            const pair = new ethers.Contract(pairAddress, pairABI, this.provider);

            const [reserves, token0, token1] = await Promise.all([
                pair.getReserves(),
                pair.token0(),
                pair.token1()
            ]);

            // Debug log the reserves and tokens
            this.log(`Pair tokens: ${token0} / ${token1}`, 'debug', 'checkUniswapV2Liquidity');
            this.log(`Raw reserves: ${reserves.reserve0.toString()} / ${reserves.reserve1.toString()}`, 'debug', 'checkUniswapV2Liquidity');

            // Check if the tokens are in the same order as the pair
            const isToken0First = token0Address.toLowerCase() === token0.toLowerCase();
            const reserve0 = isToken0First ? reserves.reserve0 : reserves.reserve1;
            const reserve1 = isToken0First ? reserves.reserve1 : reserves.reserve0;

            // Check if there's actual liquidity
            if (reserve0.isZero() || reserve1.isZero()) {
                this.log(`Zero liquidity in pair ${currentPair.name} on ${dexName}`, 'debug', 'checkUniswapV2Liquidity');
                return null;
            }

            // Calculate price
            const price = reserve1.mul(ethers.utils.parseUnits('1', currentPair.token0Decimals))
                               .div(reserve0);

            this.log(`Calculated price: ${ethers.utils.formatUnits(price, currentPair.token1Decimals)}`, 'debug', 'checkUniswapV2Liquidity');

            return {
                poolAddress: pairAddress,
                reserves: {
                    [currentPair.token0Symbol]: reserve0,
                    [currentPair.token1Symbol]: reserve1
                },
                price,
                dex: dexName
            };

        } catch (error) {
            this.log(`Error checking ${dexName} liquidity: ${error.message}`, 'error', 'checkUniswapV2Liquidity');
            return null;
        }
    }

    // Handler for UniswapV3
    async checkUniswapV3Liquidity(dexName, currentPair) {
        try {
            if (!currentPair || !currentPair.token0Address || !currentPair.token1Address) {
                this.log(`Invalid trading pair configuration for ${dexName}`, 'error', 'checkUniswapV3Liquidity');
                return null;
            }

            const factoryAddress = this.DEX_FACTORIES[dexName];
            if (!factoryAddress) {
                this.log(`No factory address found for ${dexName}`, 'error', 'checkUniswapV3Liquidity');
                return null;
            }

            const factory = new ethers.Contract(
                factoryAddress,
                ['function getPool(address,address,uint24) view returns (address)'],
                this.provider
            );

            // UniswapV3 uses fee tiers (0.05%, 0.3%, and 1%)
            const feeTiers = [500, 3000, 10000];
            let bestPool = null;
            let highestLiquidity = ethers.BigNumber.from(0);

            for (const fee of feeTiers) {
                try {
                    const poolAddress = await factory.getPool(
                        currentPair.token0Address,
                        currentPair.token1Address,
                        fee
                    );

                    if (poolAddress && poolAddress !== ethers.constants.AddressZero) {
                        const pool = new ethers.Contract(
                            poolAddress,
                            [
                                'function slot0() external view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint8 feeProtocol, bool unlocked)',
                                'function liquidity() external view returns (uint128)'
                            ],
                            this.provider
                        );

                        const [slot0Data, liquidity] = await Promise.all([
                            pool.slot0(),
                            pool.liquidity()
                        ]);

                        if (liquidity.gt(highestLiquidity)) {
                            highestLiquidity = liquidity;
                            bestPool = {
                                address: poolAddress,
                                sqrtPriceX96: slot0Data.sqrtPriceX96,
                                liquidity: liquidity,
                                fee
                            };
                        }
                    }
                } catch (feeError) {
                    this.log(`Error checking fee tier ${fee} for ${currentPair.name}: ${feeError.message}`, 'debug', 'checkUniswapV3Liquidity');
                    continue;
                }
            }

            if (!bestPool) {
                this.log(`No active UniswapV3 pools found for ${currentPair.name}`, 'debug', 'checkUniswapV3Liquidity');
                return null;
            }

            // Calculate price from sqrtPriceX96
            const price = ethers.BigNumber.from(bestPool.sqrtPriceX96)
                .mul(bestPool.sqrtPriceX96)
                .mul(ethers.utils.parseUnits('1', currentPair.token1Decimals))
                .div(ethers.BigNumber.from(2).pow(192))
                .div(ethers.utils.parseUnits('1', currentPair.token0Decimals));

            return {
                poolAddress: bestPool.address,
                price,
                dex: dexName,
                fee: bestPool.fee
            };

        } catch (error) {
            this.log(`Error checking UniswapV3 liquidity: ${error.message}`, 'error', 'checkUniswapV3Liquidity');
            return null;
        }
    }

    // Handler for 1inch (price aggregator)
    async checkOneInchLiquidity(dexName, currentPair) {
        try {
            // 1inch API endpoint for price quotes
            const apiUrl = `https://api.1inch.io/v5.0/137/quote?fromTokenAddress=${currentPair.token0Address}&toTokenAddress=${currentPair.token1Address}&amount=${ethers.utils.parseUnits('1', currentPair.token0Decimals)}`;

            const response = await fetch(apiUrl);
            const data = await response.json();

            if (!data.toTokenAmount) {
                return null;
            }

            return {
                price: ethers.BigNumber.from(data.toTokenAmount),
                dex: dexName,
                source: '1inch API'
            };

        } catch (error) {
            this.log(`Error checking 1inch prices: ${error.message}`, 'error', 'checkOneInchLiquidity');
            return null;
        }
    }

    async calculateProfitability(opportunity, pair) {
        try {
            if (!opportunity.price || !opportunity.liquidityInfo) {
                this.log('Missing price or liquidity info', 'error', 'calculateProfitability');
                return {
                    isViable: false,
                    profitPercent: 0,
                    gasCost: ethers.BigNumber.from(0)
                };
            }

            // Get current gas price
            const gasPrice = await this.provider.getGasPrice();
            const estimatedGas = ethers.BigNumber.from(300000);
            const gasCost = gasPrice.mul(estimatedGas);

            // Debug the input values
            this.log(`Calculating profitability for ${pair.name}`, 'debug', 'calculateProfitability');
            this.log(`Raw price from DEX: ${opportunity.price.toString()}`, 'debug', 'calculateProfitability');
            this.log(`Token decimals: ${pair.token0Symbol}=${pair.token0Decimals}, ${pair.token1Symbol}=${pair.token1Decimals}`, 'debug', 'calculateProfitability');

            // Convert DEX price to human-readable format
            let dexPrice;
            try {
                // For token pairs like WETH/USDC, we need to invert the price
                if (pair.token1Decimals > pair.token0Decimals) {
                    dexPrice = parseFloat(ethers.utils.formatUnits(
                        ethers.utils.parseUnits('1', pair.token1Decimals).div(opportunity.price),
                        pair.token0Decimals
                    ));
                } else {
                    dexPrice = parseFloat(ethers.utils.formatUnits(
                        opportunity.price,
                        pair.token1Decimals
                    ));
                }
            } catch (error) {
                this.log(`Error converting price: ${error.message}`, 'error', 'calculateProfitability');
                return {
                    isViable: false,
                    profitPercent: 0,
                    gasCost
                };
            }

            // Get and validate market price
            const marketPrice = await this.getMarketPrice(pair);
            if (!marketPrice) {
                this.log(`No market price available for ${pair.name}`, 'warning', 'calculateProfitability');
                return {
                    isViable: false,
                    profitPercent: 0,
                    gasCost,
                    dexPrice,
                    marketPrice: 0
                };
            }

            // Calculate profit percentage
            let profitPercent = 0;
            if (marketPrice > 0 && dexPrice > 0) {
                profitPercent = ((dexPrice - marketPrice) / marketPrice) * 100;
            }

            // Debug the calculations
            this.log(`Market Price: ${marketPrice}`, 'debug', 'calculateProfitability');
            this.log(`DEX Price: ${dexPrice}`, 'debug', 'calculateProfitability');
            this.log(`Profit %: ${profitPercent.toFixed(4)}%`, 'debug', 'calculateProfitability');
            this.log(`Min Profit Threshold: ${this.config.FLASH_LOAN.MIN_PROFIT}%`, 'debug', 'calculateProfitability');

            // Validate profitability using MIN_PROFIT from FLASH_LOAN config
            const minProfitThreshold = this.config.FLASH_LOAN.MIN_PROFIT;
            const maxProfitThreshold = 5.0; // 5% max profit to avoid false positives

            // Only consider positive profits above minimum threshold
            const isViable = profitPercent > minProfitThreshold &&
                           profitPercent < maxProfitThreshold &&
                           !isNaN(profitPercent) &&
                           isFinite(profitPercent);

            if (isViable) {
                this.log(`Viable opportunity found! Profit: ${profitPercent.toFixed(4)}%`, 'success', 'calculateProfitability');
            }

            return {
                isViable,
                profitPercent,
                gasCost,
                dexPrice,
                marketPrice
            };

        } catch (error) {
            this.log(`Error calculating profitability: ${error.message}`, 'error', 'calculateProfitability');
            return {
                isViable: false,
                profitPercent: 0,
                gasCost: ethers.BigNumber.from(0)
            };
        }
    }

    // Add method to get market price
    async getMarketPrice(pair) {
        try {
            // Return approximate market prices for common pairs
            switch(pair.name) {
                case "WETH/USDC":
                    return 3300.0;  // WETH in USDC
                case "WBTC/WETH":
                    return 18.5;    // WBTC in WETH
                case "WMATIC/USDC":
                    return 0.85;    // WMATIC in USDC
                case "DAI/USDC":
                    return 1.0;     // DAI/USDC should be close to 1
                case "WETH/DAI":
                    return 3300.0;  // WETH in DAI
                case "WETH/USDT":
                    return 3300.0;  // WETH in USDT
                case "USDC/USDT":
                    return 1.0;     // USDC/USDT should be close to 1
                case "USDC/DAI":
                    return 1.0;     // USDC/DAI should be close to 1
                default:
                    this.log(`No market price defined for ${pair.name}`, 'warning', 'getMarketPrice');
                    return null;    // Return null instead of 0
            }
        } catch (error) {
            this.log(`Error getting market price: ${error.message}`, 'error', 'getMarketPrice');
            return null;
        }
    }

    // Add execution method
    async executeArbitrage(opportunity, pair) {
        try {
            this.log(`Executing arbitrage for ${pair.name} on ${opportunity.dex}`, 'info', 'executeArbitrage');

            // Get flash loan contract
            const flashLoanContract = new ethers.Contract(
                this.config.FLASH_LOAN.CONTRACT_ADDRESS,
                this.config.FLASH_LOAN.ABI,
                this.wallet
            );

            // Calculate optimal flash loan amount based on pool liquidity
            let amount;
            if (opportunity.liquidityInfo && opportunity.liquidityInfo.reserves) {
                // Calculate 5% of the available liquidity (reduced from 20%)
                const reserves = opportunity.liquidityInfo.reserves[pair.token0Symbol];
                amount = reserves.mul(ethers.BigNumber.from(5)).div(ethers.BigNumber.from(100));

                // Add maximum amount check for safety
                const maxAmount = ethers.utils.parseUnits('5', pair.token0Decimals); // 5 tokens maximum
                if (amount.gt(maxAmount)) {
                    this.log(`Reducing flash loan amount to maximum of 5 ${pair.token0Symbol}`, 'warning', 'executeArbitrage');
                    amount = maxAmount;
                }
            } else {
                // Fallback to minimum amount
                amount = ethers.utils.parseUnits('0.1', pair.token0Decimals); // Reduced from 1
            }

            // Validate amount
            if (!amount || amount.isZero()) {
                this.log('Invalid flash loan amount calculated', 'error', 'executeArbitrage');
                return false;
            }

            const formattedAmount = ethers.utils.formatUnits(amount, pair.token0Decimals);
            this.log(`Flash loan amount: ${formattedAmount} ${pair.token0Symbol}`, 'debug', 'executeArbitrage');

            // Additional safety check for large amounts
            if (parseFloat(formattedAmount) > 5) {
                this.log(`Flash loan amount too large: ${formattedAmount} ${pair.token0Symbol}`, 'error', 'executeArbitrage');
                return false;
            }

            // Estimate gas
            const gasPrice = await this.provider.getGasPrice();
            const gasLimit = ethers.BigNumber.from(500000);
            const gasCost = gasPrice.mul(gasLimit);

            // Log transaction details
            this.log(`Gas Price: ${ethers.utils.formatUnits(gasPrice, 'gwei')} Gwei`, 'debug', 'executeArbitrage');
            this.log(`Estimated Gas Cost: ${ethers.utils.formatEther(gasCost)} MATIC`, 'debug', 'executeArbitrage');

            // Prepare transaction parameters
            const gasMultiplier = ethers.BigNumber.from(
                Math.floor((this.config.FLASH_LOAN.GAS_MULTIPLIER || 1) * 100)
            ).div(ethers.BigNumber.from(100));

            const txParams = {
                gasLimit,
                gasPrice: gasPrice.mul(gasMultiplier)
            };

            // Validate token address
            if (!ethers.utils.isAddress(pair.token0Address)) {
                this.log(`Invalid token address: ${pair.token0Address}`, 'error', 'executeArbitrage');
                return false;
            }

            // Execute flash loan
            this.log(`Executing flash loan for ${formattedAmount} ${pair.token0Symbol}...`, 'info', 'executeArbitrage');

            // Debug transaction parameters
            this.log(`Transaction Parameters:`, 'debug', 'executeArbitrage');
            this.log(`- Gas Limit: ${gasLimit.toString()}`, 'debug', 'executeArbitrage');
            this.log(`- Gas Price: ${txParams.gasPrice.toString()}`, 'debug', 'executeArbitrage');
            this.log(`- Token Address: ${pair.token0Address}`, 'debug', 'executeArbitrage');
            this.log(`- Amount: ${amount.toString()}`, 'debug', 'executeArbitrage');

            const tx = await flashLoanContract.requestFlashLoan(
                pair.token0Address,
                amount,
                txParams
            );

            this.log(`Transaction sent: ${tx.hash}`, 'info', 'executeArbitrage');

            // Wait for confirmation
            const receipt = await tx.wait();

            if (receipt.status === 1) {
                this.log(`Arbitrage executed successfully!`, 'success', 'executeArbitrage');
                this.log(`Transaction hash: ${receipt.transactionHash}`, 'success', 'executeArbitrage');
                return true;
            } else {
                this.log(`Arbitrage failed - transaction reverted`, 'error', 'executeArbitrage');
                return false;
            }

        } catch (error) {
            this.log(`Error executing arbitrage: ${error.message}`, 'error', 'executeArbitrage');
            if (error.data) {
                this.log(`Additional error data: ${error.data}`, 'error', 'executeArbitrage');
            }
            return false;
        }
    }

    async checkKyberSwapLiquidity(dexName, currentPair) {
        try {
            const factoryAddress = this.DEX_FACTORIES[dexName];
            const factory = new ethers.Contract(
                factoryAddress,
                [
                    'function getPair(address tokenA, address tokenB) view returns (address)',
                    'function allPairs(uint) view returns (address)',
                    'function allPairsLength() view returns (uint)'
                ],
                this.provider
            );

            this.log(`Checking KyberSwap pair: ${currentPair.token0Symbol}/${currentPair.token1Symbol}`, 'debug', 'checkKyberSwapLiquidity');

            const poolAddress = await factory.getPair(
                currentPair.token0Address,
                currentPair.token1Address
            );

            if (!poolAddress || poolAddress === ethers.constants.AddressZero) {
                this.log(`No KyberSwap pool found for ${currentPair.name}`, 'debug', 'checkKyberSwapLiquidity');
                return null;
            }

            const poolABI = [
                'function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)',
                'function token0() external view returns (address)',
                'function token1() external view returns (address)'
            ];

            const pool = new ethers.Contract(poolAddress, poolABI, this.provider);
            const [reserves, token0, token1] = await Promise.all([
                pool.getReserves(),
                pool.token0(),
                pool.token1()
            ]);

            const isToken0First = currentPair.token0Address.toLowerCase() === token0.toLowerCase();
            const reserve0 = isToken0First ? reserves.reserve0 : reserves.reserve1;
            const reserve1 = isToken0First ? reserves.reserve1 : reserves.reserve0;

            // Calculate price
            const price = reserve1.mul(ethers.utils.parseUnits('1', currentPair.token0Decimals))
                               .div(reserve0);

            return {
                poolAddress,
                reserves: {
                    [currentPair.token0Symbol]: reserve0,
                    [currentPair.token1Symbol]: reserve1
                },
                price,
                dex: dexName
            };

        } catch (error) {
            this.log(`Error checking KyberSwap liquidity: ${error.message}`, 'error', 'checkKyberSwapLiquidity');
            return null;
        }
    }
}

// Add this check before running main
if (!process.env.PRIVATE_KEY) {
    console.error('ERROR: PRIVATE_KEY environment variable is required');
    console.error('Please set it before running the bot:');
    console.error('export PRIVATE_KEY=your_private_key_here');
    process.exit(1);
}

async function main() {
    try {
        console.log('Starting Polygon Arbitrage Bot...');
        const bot = new ArbitrageScanner();
        await bot.initialize();
        await bot.startScanning();
    } catch (error) {
        console.error('Fatal error:', error);
        process.exit(1); // Exit with error code
    }
}

// Add global error handlers
process.on('unhandledRejection', (error) => {
    console.error('Unhandled promise rejection:', error);
    process.exit(1);
});

process.on('uncaughtException', (error) => {
    console.error('Uncaught exception:', error);
    process.exit(1);
});

main().catch(error => {
    console.error('Bot crashed:', error);
    process.exit(1);
});

module.exports = ArbitrageScanner;